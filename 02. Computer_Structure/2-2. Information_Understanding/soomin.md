# 02-2 컴퓨터가 이해하는 정보
CPU는 기본적으로 0과 1만을 이해 
- 비트 → 바이트(8bit) → kB(1000byte) → MB → GB → TB
- 워드
    - CPU가 한 번에 처리할 수 있는 데이터의 크기
    - CPU는 프로그램을 워드 단위로 읽어 들이고 처리</br>
      CPU 한 번에 32bit 처리 → 1 word = 32bit</br>
      현대 컴퓨터 대부분의 워드 크기는 32 or 64

## 데이터
### ✅0과 1로 숫자
CPU는 컴퓨터 내부에서 2진법을 사용 

- 2진수로 소수 나타내기
  
  표현하고자 하는 소수와 실제로 저장된 소수 간에 오차가 존재(=정밀도에 한계가 존재) → why? 부동 소수정 방식

**IEEE 754**

오늘날 대부분 컴퓨터의 부동소수점 저장 방식
- 가수의 정수부 : 1로 통일된 정규화한수가 저장</br>
    즉, 가수 = 1.XXX…의 형태
- $2^{지수}$ * 1.XXX… </br>
    지수와 XXX…에 해당하는 소수 부분만 저장 (가수에서 1을 제외) 
    지수를 저장할 때는 bias값이 더해져서 저장</br>
    bias = $2^{k-1} -1$

- 10진수 $0.1 = m * 10^n$의 꼴로 간단하게 나타내기 가능</br>
같은 수를 $1.m * 2^n$의 꼴로 표현하려면 무한하게 많은 소수점이 필요

  컴퓨터의 저장공간은 한정적 → 무한히 많은 소수점을 저장할 수는 없음</br>
  딱 맞아떨어지지 않는 소수를 표현할 때는 일부 소수점을 생략하여 저장 → 따라서, 오차가 발생

### ✅0과 1로 문자
**문자 집합** - 컴퓨터가 이해할 수 있는 문자들의 집합

**문자 인코딩** - 문자 집합에 속한 문자를 컴퓨터가 이해하는 0과 1로 이루어진 문자 코드로 변환하는 과정

**문자 디코딩** - 0과 1로 표현된 문자를 사람이 이해하는 문자로 변환하는 과정

▶️ **아스키**
- 초창기 컴퓨터에서 사용하던 문자 집합
- 하나의 아스키 문자를 표현하기 위해서는 8비트를 사용
  - 8비트 중 1비트는 패리티비트 - 오류 검출용
  - 7비트로 표현 → $2^7$→ 총 128개 문자 표현
- 아스키 코드
  - 아스키 문자들은 0~127까지의 숫자 중 하나의 고유한 수에 대응
  - 아스키 코드의 인코딩 방식 - 2진수로 표현함으로써 아스키 문자를 0과 1로 대응

▶️ **EUC-KR**
- 아스키 코드는 한글을 표현할 수 없어서 등장
- 아스키 문자를 표현할 때는 1바이트, 하나의 한글 글자를 표현할 때는 2바이트 크기의 코드를 부여
- 총 2350개 정도의 한글 단어를 표현 가능 → 모든 한글 조합을 표현할 수 있을 정도로 많은 양은 아님

▶️ **유니코드**
- EUC-KR에 비해 훨씬 많아진 통일된 문자 집합, 현대 가장 많이 사용되는 표준 문자 집합
- 대부분의 언어를 지원 - 국가별로 다른 문자 집합과 인코딩 방식을 준비할 필요가 없음
- 특징
    - 아스키코드 & EUC-KR → 글자에 부여된 값을 그대로 인코딩 값으로 대응
    - 유니코드는 글자에 부여된 값 자체를 인코딩된 값으로 삼지 않고, 이 값을 다양한 방법으로 인코딩</br>
        문자 → 코드 포인트 → 인코딩 → utf-8 / utf-16 / utf-32
    
      유니코드 = 문자의 집합

      utf-x = 유니코드 문자에 부여된 값을 인코딩하는 방식, 가변길이 인코딩 방식

▶️ **base64**
- 문자뿐만 아니라, 이진 데이터까지 변환할 수 있는 인코딩 방식
- 문자보다는 이진 데이터를 인코딩하는 데에 더 많이 사용
- 이미지 등 단순 문자 이외의 데이터까지 모두 아스키 문자 형태로 표현 가능
- 64진법을 의미
    - 64진수 하나를 표현하기 위해서 $2^6$의 지수인 6비트가 필요 → 6비트씩 나누어 하나의 문자로 변환
    - 6비트씩 나누어 떨어지지 x → 0으로 채워지는 패딩이 되고, 이는 ‘=’로 인코딩

## 명령어
하나의 명령어는 연산 코드와 0개 이상의 오퍼랜드로 구성
- 연산 코드(연산자) : 명령어가 수행할 동작
- 오퍼랜드(피연산자) : 동작에 사용될 [데이터 or 데이터가 저장된 위치(주소 필드)]
 
오퍼랜드에 메모리 주소가 명시될 경우 → 추가 메모리 접근 필요 

### ✅기계어와 어셈블리어
- 기계어 : CPU가 이해할 수 있도록 0과 1로 표현된 정보를 있는 그대로 표현한 언어
- 어셈블리어 : 0과 1로 표현된 기계어를 읽기 편한 형태로 단순 번역한 언어
CPU가 다르면 기계어와 어셈블리어도 달라질 수 있음 (CISC기반, RISC기반)

### ✅명령어 사이클
CPU가 명령어를 처리하는 과정에서 프로그램 속 각각의 명령어들은 일정한 주기를 반복하며 실행

🟢 **인출(fetch) 사이클**</br>
메모리에 있는 명령어를 CPU로 가지고 오는 단계

🟢 **실행(execution) 사이클**</br>
CPU로 인출한 명령어를 실행하는 단계 

🟢 **간접(indirect) 사이클**</br>
명령어를 실행하기 위해 한 번 더 메모리에 접근하는 단계</br>
`인출` - 메모리에 접근이 더 필요한 경우 → `간접` → `실행`

🟢 **인터럽트(interrupt) 사이클**</br>
인터럽트를 처리하는 단계
