# 2-2 컴퓨터가 이해하는 정보

## ✅ 데이터

- CPU는 기본적으로 0과 1만을 이해
- **비트(bit)**: 0과 1을 나타내는 가장 작은 정보의 단위
  - N비트는 2^N개의 정보를 표현
- **바이트(byte)**: 여덟 비트를 묶은 단위
  - 하나의 바이트로 표현할 수 있는 정보는 2^8 = 256개

### 단위 변환

1 byte (8 비트) → 1 kB (1,000 바이트) → 1 MB (1,000 킬로바이트) → 1 GB (1,000 메가바이트) → 1 TB (1,000 기가바이트)

- **워드(word)**: CPU가 한 번에 처리할 수 있는 데이터의 크기
  - CPU는 프로그램을 워드 단위로 읽어 들이고 처리
  - 현대 컴퓨터 대부분의 워드 크기는 32비트, 혹은 64비트

## ✅ 데이터 - 0과 1로 숫자 표현하기

- CPU는 컴퓨터 내부에서 2진법(binary)을 사용

## ✅ 부동 소수점(floating point) 방식

- 소수점이 고정되어 있지 않은 소수 표현 방식
- 필요에 따라 소수점의 위치가 이동할 수 있고, 유동적(floating)
  - 2의 지수가 양수일 때: 2^소수점을 왼쪽으로 이동한 횟수
  - 2의 지수가 음수일 때: 2^소수점을 오른쪽으로 이동한 횟수

### ✅ IEEE 754

- 부동 소수점 저장 방식
- 오늘날 대부분의 컴퓨터는 2진수의 지수와 가수를 다음과 같은 형식으로 저장
- **가수의 정수부**: 1로 통일된 정규화한 수(normalized number)가 저장
  - 즉, 가수는 1. xxxx의 형태

---

## ✅ 문자 집합 (Character Set)

- 컴퓨터가 이해할 수 있는 문자들의 집합

## ✅ 문자 인코딩 (Character Encoding)

- 문자 집합에 속한 문자를 컴퓨터가 이해하는 0과 1로 이루어진 문자 코드로 변환하는 과정

## ✅ 문자 디코딩 (Character Decoding)

- 0과 1로 표현된 문자를 사람이 이해하는 문자로 변환하는 과정

## ✅ 아스키 (ASCII)

- 초창기 컴퓨터에서 사용하던 문자 집합 중 하나로, 영어의 알파벳과 아라비아 숫자, 일부 특수 문자를 포함
- 하나의 아스키 문자를 표현하기 위해서는 8비트(1바이트)를 사용
  - 8비트 중 1비트는 패리티비트(parity bit) - 오류 검출을 위해 사용되는 비트
  - 실질적으로 문자 표현을 위해 사용되는 비트는 7비트
  - 7비트로 표현할 수 있는 정보의 가짓수는 2^7개이므로 총 128개의 문자를 표현
- **아스키 코드**: 아스키 문자들은 0부터 127까지의 숫자 중 하나의 고유한 수에 대응
  - 아스키 코드의 인코딩 방식: 2진수로 표현함으로써 아스키 문자를 0과 1로 대응
- **코드 포인트**: 문자 인코딩에서 ‘글자에 부여된 고유한 값’
  - 예: 아스키 문자 ‘A’의 코드 포인트는 65

## ✅ EUC-KR

- 아스키 코드는 한글을 표기할 수 없어서 등장한 한글 인코딩 방식 중 하나
- 문자 집합 기반의 인코딩 방식
  - 아스키 문자를 표현할 때는 1바이트, 하나의 한글 글자를 표현할 때는 2바이트 크기의 코드를 부여

## ✅ 유니코드 (Unicode)

- 한글을 포함해 EUC-KR에 비해 훨씬 많은 언어, 특수문자, 화살표, 이모티콘까지 코드로 표현할 수 있는 통일된 문자 집합
- 대부분의 언어를 지원 - 국가별로 다른 문자 집합과 인코딩 방식을 준비할 필요 없음
- 현대 가장 많이 사용되는 표준 문자 집합
- 특징:
  - 아스키 코드나 EUC-KR은 글자에 부여된 값을 그대로 인코딩 값으로 대응
  - 유니코드는 글자에 부여된 값 자체를 인코딩된 값으로 삼지 않고, 이 값을 다양한 방법으로 인코딩
  - UTF-8, UTF-16, UTF-32는 유니코드 문자에 부여된 값을 인코딩하는 방식

## ✅ base64

- 문자뿐만 아니라, 이진 데이터까지 변환할 수 있는 인코딩 방식
- 문자보다는 이진 데이터를 인코딩하는 데에 더 많이 사용
- 이미지 등 단순 문자 이외의 데이터까지 모두 아스키 문자 형태로 표현 가능
- 64진법을 의미
  - 하나의 base64 인코딩 값을 표현하기 위해 64개의 문자가 사용
  - 64진수 하나를 표현하기 위해서는 2^6의 지수인 6비트가 필요
  - 따라서 변환할 데이터를 6비트씩 나누어 다음 표에 있는 하나의 문자로 변환

---

# 명령어

- 명령어는 수행할 동작과 수행할 대상으로 구성
    - **수행할 대상**: 수행할 동작에 사용될 `데이터` 자체 or 동작에 사용될 데이터가 `저장된 위치 (주소 필드)`

- 하나의 명령어는 연산 코드와 0개 이상의 오퍼랜드로 구성
    - **연산 코드 (opcode)**: ‘명령어가 수행할 동작’
    - **오퍼랜드 (operand)**: ‘동작에 사용될 데이터’ or ‘동작에 사용될 데이터가 저장된 위치’
    
    → 연산 코드는 연산자, 오퍼랜드는 피연산자라고도 부름

- 명령어에 사용된 오퍼랜드에 메모리 주소가 명시 될 경우
    - 추가 메모리 접근 필요 (ex. 명령어 ‘더해라, 100번지 값에, 10을’)
    
- 대표적인 연산코드의 유형:
    - **데이터 전송**, **산술/논리 연산**, **제어 흐름 변경**, **입출력 제어**
    
---

## 기계어와 어셈블리어

- **기계어 (machine code)**: CPU가 이해할 수 있도록 0과 1로 표현된 정보를 있는 그대로 표현한 언어
- **어셈블리어 (assembly language)**: 0과 1로 표현된 기계어를 읽기 편한 형태로 단순 번역한 언어
- CPU가 다르면 기계어와 어셈블리어도 달라질 수 있음

---

## 명령어 사이클 (Instruction Cycle)

CPU가 명령어를 처리하는 과정에서 프로그램 속 각각의 명령어들은 일정한 주기를 반복하며 실행됩니다.

1. **인출 사이클 (fetch cycle)**: 메모리에 있는 명령어를 CPU로 가지고 오는 단계
2. **실행 사이클 (execution cycle)**: CPU로 인출한 명령어를 실행하는 단계
3. **간접 사이클 (indirect cycle)**: 명령어를 실행하기 위해 한 번 더 메모리에 접근하는 단계
4. **인터럽트 사이클 (interrupt cycle)**: 인터럽트를 처리하는 단계

