# 2-3 CPU

## ✅ 레지스터

- CPU 안에 있는 작은 임시 저장장치
    - 다양한 레지스터들이 존재하며, 각기 다른 이름과 역할
- 프로그램을 이루는 데이터와 명령어가 프로그램의 실행 전후로 레지스터에 저장
- WinDbg(윈도우 운영체제), gdb(리눅스, 맥OS 운영체제) 등의 디버깅 도구를 이용해 관찰

### 주요 레지스터

1. **프로그램 카운터 (PC, Program Counter)**
    - 메모리에서 다음으로 읽어 들일 명령어의 주소를 저장
    - 명령어 포인터라고 부르는 CPU도 있음
    - 프로그램 카운터 값이 1씩 증가
        - 곧 다음으로 읽어 들일 메모리 주소가 1씩 증가하는 것과 같음
        - 프로그램의 실행 흐름이 순차적이지 않을 때는 프로그램 카운터 값이 임의의 위치로 변경

2. **명령어 레지스터 (IR, Instruction Register)**
    - 해석할 명령어, 즉 메모리에서 방금 읽어 들인 명령어를 저장

3. **범용 레지스터 (General Purpose Register)**
    - 일반적인 상황에서 자유롭게 사용할 수 있는 레지스터
    - 데이터, 명령어, 주소 모두 저장 가능
    - 일반적으로 CPU 안에는 여러 개의 범용 레지스터들이 존재

4. **플래그 레지스터 (Flag Register)**
    - 연산의 결과 혹은 CPU 상태에 대한 부가 정보인 플래그 값을 저장
    - 플래그: CPU가 명령어를 처리하는 과정에서 반드시 참조해야 할 상태 정보를 의미하는 비트

5. **스택 포인터 (Stack Pointer)**
    - 메모리 내 스택 영역의 최상단 스택 데이터 위치를 가리키는 특별한 레지스터
    - 마지막으로 스택에 저장된 데이터의 위치를 가리키는 레지스터이자 스택이 채워진 정도를 나타내는 레지스터

---

## ✅ 인터럽트 (Interrupt)

- CPU의 작업을 방해하는 신호

### 동기 인터럽트 (Synchronous Interrupts)
- CPU에 의해 발생
    - 예외적인 상황(예상치 못한 상황)을 마주쳤을 때 발생
    - 예외(Exception)라고도 부름

### 비동기 인터럽트 (Asynchronous Interrupts)
- 주로 입출력 장치에 의해 발생
    - 알림의 역할을 함
    - CPU가 프린터와 같은 입출력 작업을 부탁하고, 작업을 끝낸 입출력 장치가 CPU에게 완료 알림(인터럽트)을 보냄
    - 키보드, 마우스와 같은 입출력 장치가 어떤 입력을 받아들였을 때 이를 처리하기 위해 CPU에게 입력 알림(인터럽트)을 보냄
    - 하드웨어 인터럽트라고도 부름

---

## ✅ 하드웨어 인터럽트

- CPU는 효율적으로 명령어를 처리하기 위해 하드웨어 인터럽트를 사용
    - **사용 이유**: 효율적으로 명령어를 처리할 수 있도록 돕기 위함
        - 입출력 완료 여부를 확인하기 위한 CPU 사이클 낭비를 최소화
        - CPU가 다른 일을 수행할 수 있는 시간을 벌어 줌
        - 인터럽트와 대비되는 **폴링** 기법: 입출력 장치의 상태가 어떤지, 처리할 데이터가 있는지 주기적으로 확인하는 것

### CPU가 하드웨어 인터럽트를 처리하는 순서

1. 입출력 장치는 CPU에게 **인터럽트 요청 신호**를 보냄
2. CPU는 실행 사이클이 끝나고 명령어를 인출하기 전, 항상 인터럽트 여부 확인
3. CPU는 인터럽트 요청을 확인 후, **인터럽트 플래그**를 통해 현재 인터럽트를 받아들일 수 있는지 여부 확인
4. 인터럽트를 받아들일 수 있다면 CPU가 지금까지의 작업을 백업
5. CPU는 **인터럽트 벡터**를 참조하여 **인터럽트 서비스 루틴** 실행
6. 인터럽트 서비스 루틴 실행이 끝나면 4번에서 백업해 둔 작업을 복구하여 실행 재개

---

## ✅ 인터럽트 관련 용어

- **인터럽트 요청 (Interrupt Request) 신호**
    - 인터럽트 하기 전에 CPU에게 인터럽트 가능 여부 확인

- **인터럽트 플래그 (Interrupt Flag)**
    - 하드웨어 인터럽트를 받아들일지, 무시할지를 결정하는 플래그
    - CPU가 인터럽트 요청을 수용하기 위해서는 플래그 레지스터의 인터럽트 플래그가 활성화되어 있어야 함
    - **인터럽트 플래그**로 막을 수 있는 인터럽트 (maskable interrupt), 막을 수 없는 인터럽트 (non-maskable interrupt)

- **인터럽트 서비스 루틴 (ISR, Interrupt Service Routine)**
    - 인터럽트를 처리하기 위한 프로그램
    - 인터럽트 핸들러 (interrupt handler)라고도 부름
    - CPU가 인터럽트 요청을 받아들이기로 하면, 인터럽트 서비스 루틴을 실행
    - 어떤 인터럽트가 발생했을 때 해당 인터럽트를 어떻게 처리할지에 대한 정보로 이루어진 프로그램
    - CPU가 인터럽트를 처리한 후, 본래 수행하던 작업으로 다시 되돌아옴

- **인터럽트 벡터 (Interrupt Vector)**
    - 인터럽트 서비스 루틴을 식별하기 위한 정보
    - CPU는 하드웨어 인터럽트 요청을 보낸 대상으로부터 버스를 통해 인터럽트 벡터를 전달받음
    - 서비스 루틴의 시작 주소를 포함 → CPU는 처음부터 특정 인터럽트 서비스 루틴을 실행 가능

---

# ✅ 예외 (동기 인터럽트)

## 예외 종류
- **폴트**, **트랩**, **중단**, **소프트웨어 인터럽트** 등

## CPU의 예외 처리
- CPU는 예외가 발생하면 하던 일을 중단하고 해당 예외 처리
- 예외를 처리하고 나면 다시 본래 하던 작업으로 되돌아와 실행 재개

### 예외 처리 후 실행 재개
- **폴트 (Fault)**: 예외를 처리한 직후 예외가 발생한 명령어부터 실행 재개

- **트랩 (Trap)**: 예외를 처리한 직후 예외가 발생한 명령어의 다음 명령어부터 실행 재개 
  (예: 디버깅의 브레이크 포인트)
  
- **중단 (Abort)**: CPU가 실행 중인 프로그램을 강제로 중단시킬 수밖에 없는 심각한 오류 발견 시 발생
  
- **소프트웨어 인터럽트 (Software Interrupt)**: 시스템 콜이 발생했을 때 발생

---

# ✅ CPU 성능 향상

## CPU 클럭 속도
- **클럭 (Clock)**: 컴퓨터의 부품을 일사불란하게 움직일 수 있게 하는 시간 단위, 헤르츠(Hz)로 측정
- **클럭 속도**: CPU의 속도 단위로 간주
  - 클럭 속도를 필요 이상으로 높이면 컴퓨터 발열이 심해질 수 있음
  - 클럭 속도를 높이는 것만으로 CPU 성능을 높이는 데 한계

---

# ✅ 멀티코어와 멀티 스레드

## 코어 (Core)
- CPU 내에서 명령어를 읽어 들이고, 해석하고, 실행하는 부품

## 스레드 (Thread)
- **하드웨어적인 스레드** (하드웨어 스레드)
- **소프트웨어적인 스레드** (프로그램 및 운영체제에서 사용하는 스레드)

### 하드웨어 스레드
- 하나의 코어가 동시에 처리하는 명령어의 단위
- 멀티스레드 CPU, 논리 프로세서 (Logical Processor).

### 소프트웨어 스레드
- 하나의 프로그램에서 독립적으로 실행되는 단위
- CPU 코어 수와 코어별 스레드 주(Thread(s) per core)가 각각 1개.

### 하드웨어와 소프트웨어 스레드의 차이
- 하드웨어 스레드는 실제 하드웨어에 의해 처리되는 단위
- 소프트웨어 스레드는 프로그램 내에서 논리적으로 처리되는 단위

---

## ✅ 멀티코어와 멀티 스레드

- **병렬성 (Parallelism)**: 작업을 물리적으로 동시에 처리하는 성질
- 예를 들어, **4코어 8스레드 CPU**가 4개의 명령어를 동시에 실행할 수 있습니다.

- **소프트웨어 스레드**:
  - **동시성 (Concurrency)**: 동시에 작업을 처리하는 것처럼 보이는 성질
  - 논리적인 실행 단위

---

# ✅ 파이프라이닝을 통한 명령어 병렬 처리

## 명령어 병렬 처리 기법 (Instruction-Level Parallelism)
- 여러 명령어를 동시에 처리하여 CPU를 한시도 쉬지 않도록 하여 성능을 향상시키는 기법
- **명령어 파이프라이닝 (Instruction Pipelining)**: 명령어들을 명령어 파이프라인에 넣고 동시에 처리하는 기법

### 명령어가 처리되는 과정
1. 명령어 인출 (Instruction Fetch)
2. 명령어 해석 (Instruction Decode)
3. 명령어 실행 (Execute Instruction)
4. 결과 저장 (Write Back)

- 같은 단계가 겹치지 않으면 CPU는 각각의 단계를 동시에 실행 가ㅇ

---

## 파이프라인 위험 (Pipeline Hazard)
- 파이프라이닝이 실패하여 성능 향상이 이루어지지 않는 상황

### 위험 종류
1. **데이터 위험 (Data Hazard)**: 명령어 간의 데이터 의존성에 의해 발생

2. **제어 위험 (Control Hazard)**: 프로그램 카운터의 갑작스러운 변화에 의해 발생

3. **구조적 위험 (Structural Hazard)** 또는 **자원 위험 (Resource Hazard)**: 명령어들이 겹쳐 실행되는 과정에서 CPU 부품이 겹쳐 사용될 때 발생
