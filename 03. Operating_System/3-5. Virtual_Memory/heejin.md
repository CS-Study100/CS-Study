# 3-5. 가상 메모리
## 🤔 CPU는 어떻게 메모리에 적재된 프로세스의 주소를 인식하고 관리할까 ?

## ✅ 물리 주소와 논리 주소
CPU와 프로세스는 메모리의 하드웨어 상 실제 주소인 **물리 주소**가 아니라 다른 주소 체계인 **논리 주소**를 이용한다.
**논리 주소** : 프로세스마다 부여되는 0번지부터 시작하는 주소 체계
**메모리 관리 장치(MMU, Memory Management Unit**) : CPU와 메모리 사이에 위치하며, CPU가 이해하는 논리주소를 메모리가 이해하는 물리주소로 변환하는 역할

## ✅ 스와핑과 연속 메모리 할당
프로세스가 이러한 주소 체계를 통해 어떻게 메모리에 할당될까 ?
### 1️⃣ 스와핑 
메모리에 적재된 프로세스들 중에는 현재 실행되고 있지 않은 프로세스들을 임시로 `스왑 영역` 이라는 보조기억 장치의 일부인 영역으로 쫓아낸다.
`스와핑` : 프로세스를 쫓아낸 자리에 생긴 메모리 상의 빈 공간에 다른 프로세스를 적재하여 실행하는 메모리 관리 방식
`스왑 아웃` : 현재 실행되지 않는 프로세스가 메모리에서 스왑 영역으로 옮겨지는 것
`스왑 인` : 스왑 영역에 있는 프로세스가 다시 메모리로 옮겨오는 것

### 2️⃣ 연속 메모리 할당과 외부 단편화
프로세스에 연속적인 메모리 공간을 할당하는 방식
`외부 단편화` : 프로세스 바깥에 생기는 빈 공간들은 분명 빈 공간이지만 그보다 큰 프로세스를 적재하기 어려운 상황을 초래하고, 메모리 낭비로 이어지는 현상

#### 1️⃣ 스와핑 과 2️⃣ 연속 메모리 할당의 문제
- `외부 단편화` : 적재와 삭제를 반복하며 프로세스들 사이에 발생한는 것
- `물리 메모리보다 큰 프로세스 실행 X`
**➡️ 운영체에의 메모리 관리 기술인 가상 메모리로 문제 해결 !!**

## ✅ 가상 메모리(vitual memory)
실행하고자 하는 프로그램의 일부만 메모리에 적재해, 실제 메모리보다 더 큰 프로세스를 실행할 수 잇도록 만드는 메모리 관리 기법
- 보조기억장치의 일부를 메모리처럼 사용하거나 프로세스의 일부만 메모리에 적재함으로써 메모리를 실제 크기보다 더 크게 보이게 하는 기술
`가상 주소 공간` : 가상 메모리 기법으오 생성된 논리 주소 공간
가상 메모리 관리 기법 : 세그멘테이션, 페이징 

## ✅ 세그멘테이션(segmentation)
프로세스를 일정한 크기의 페이지 단위가 아닌 가변적인 크기의 `세그먼트` 단위로 분할하는 방식
- 세그먼트의 크기가 일정하지 않기 때문에 `외부 단편화` 발생 가능 

## ✅ 페이징(paging)
프로세스의 논리 주소 공간을 `페이지` 라는 일정한 단위로 나누고, 물리 주소 공간을 페이지와 동일한 크기의 `프레임` 이라는 일정한 단위로 나눈 뒤 `페이지를 프레임에 할당하는 가상 메모리 관리 기법`이다.
➡️ **이와 같이 메모리를 할당하면 `외부 단편화` 발생 X**
- 페이징 시스템에서의 스왑아웃은 `페이지 아웃`, 스왑인은 `페이지 인` 라고 부름
- 페이징을 통해 물리 메모리보다 큰 크기의 프로세스 실행 가능해짐

### ☑️ 페이지 테이블(page table)
물리 메모리 내에 페이지가 불연속적으로 배치되어있어 CPU 입장에서는 다음으로 실행할 페이지의 위치를 찾기가 어려움
➡️ 이러한 문제를 해결하기 위해 `페이지 테이블` 활용
-`페이지 테이블` : 프로세스의 페이지와 실제로 적재된 프레임을 짝지어주는 정보
- 프로세스마다 각자의 페이지 테이블 정보를 갖고 있으므로, CPU가 서로 다른 프로세스를 실행할 때는 각 프로세스의 페이지 테이블을 참조하여 메모리에 접근
- `테이블 엔트리` : 페이지 테이블을 구성하고 있는 각각의 행들 
 - `유효 비트` : 해당 페이지에 접근이 가능한지 여부를 알려 주는 매우 중요한 정보
  - 현재 페이지가 메모리(1)/보조기억장치(0)에 적재되어있는지 알려주는 비트
  - `페이지 폴트` 예외 : CPU가 메모리에 적재되지 않은 페이지, 즉 유효 비트가 0인 페이지에 접근시 발생
 - `보호 비트` : 페이지 보호 기능을 위해 존재하는 비트 
  - r, w, x 조합으로 페이지에 접근할 권한 제한
 - `참조 비트` : CPU가 해당 페이지에 접근한 적이 있는지의 여부를 나타내는 비트
 - `수정 비트` : 해당 페이지에 데이터를 쓴 적이 있는지의 여부를 알려주는 비트

### ☑️ 페이지 테이블 베이스 레지스터(PTBR)
	페이징은 외부 단편와 문제를 해결할 수 있지만, 내부 단편화 문제를 야기할 수 있다.    
	`내부 단편화` : 페이지 하나의 크기보다 작은 크기로 발생하게 되는 메모리 낭비
특정 프로세스의 페이지 테이블이 적재된 메모리 상의 위치를 가리키는 특별한 레지스터
- 프로세스마다 가지는 정보이므로 각 PCB에 기록되며, 다른 프로세스로의 문맥 교환이 발생할 때 변경된다.

#### 메모리 접근 횟수와 메모리 용량
모든 프로세스의 페이지 테이블을 메모리에 두는 것은 `메모리 접근 횟수` 가 많아지고, `메모리 용량` 을 많이 차지하기 때문에 비효율적이다.
운영체제는 모든 페이지 테이블을 메모리에 적재하는 것을 가급적 지양 !!
각각의 문제 상황과 해결 방법을 알아보자.

##### 메모리 접근 횟수
TLB 사용해서 해결
- `TLB` : 페이지 테이블의 캐시 메모리 
- TLB는 페이지 테이블의 캐시이므로 참조 지역성의 원리에 근거해 자주 사용할 법한 페이지 위주로 페이지 테이블의 일부 내용을 저장
- `TLB 히트` : CPU가 접근하려는 논리 주소의 페이지 번호가 TLB에 있을 경우, TLB는 CPU에게 해당 페이지 번호가 적재된 프레임 번호를 알려줌
 - 메모리 접근 횟수를 낮추려면 `TLB 히트율` 을 높여야함
- `TLB 미스` : 페이지 번호가 TLB에 없는 경우에는 어쩔 수 없이 페이지가 적재된 프레임을 알기 위해 메모리 내의 페이지 테이블에 접근하는 수밖에 없음


##### 메모리 용량
`계층적 페이징` : 페이지 테이블을 페이징하는 방식

### ☑️ 페이징 주소 체계
논리 주소 : <페이지 번호, 변위> 형태
물리 주소 : <프레임 번호, 변위> 형태
`페이지 번호` : 몇 번째 페이지 번호에 접근할지 나타냄
`변위` : 접근하려는 주소가 페이지(프레임) 시작 번지로부터 얼만큼 떨어져 있는지를 나타내는 정보


### ☑️ 페이지 교체 알고리즘
프로세스를 이루는 모든 페이지가 메모리에 적재되지는 않아도 된다.
`요구 페이징` : 메모리에 프로세스를 적재할 때 처음부터 모든 페이지를 적재하지 않고, 메모리에 필요한(요구되는) 페이지만을 적재하는 기법
`순수 요구 페이징` : 아무런 페이지도 메모리에 적재하지 않은 채 무작정 프로세스를 실행할 수 있음
- 첫명령어를 실행하는 순간부터 페이지 폴트가 발생, 실행에 필요한 페이지가 어느 정도 적재된 이후부터는 페이지 폴트의 발생 빈도 떨어짐
`페이지 교체 알고리즘` : 메모리에 적재된 페이지 중 보조기억장치로 내보낼 페이지를 선택하는 방법
#### FIFO 페이지 교체 알고리즘
메모리에 가장 먼저 적재된 페이지부터 스왑 아웃하는 페이지 교체 알고리즘
#### 최적 페이지 교체 알고리즘
앞으로의 사용빈도가 가장 낮은 페이지를 교체하는 알고리즘
#### LRU 페이지 교체 알고리즘
가장 적게 '사용한' 페이지를 교체하는 알고리즘

