# 03-5. 가상 메모리
- CPU와 프로세스가 메모리 몇 번지에 무엇이 저장되어 있는지까지 알지X
- CPU의 레지스터가 메모리 만큼 커야하는데 그러지 못하기 때문
- 어떻게 CPU가 메모리에 적재된 프로세스의 주소를 인식하고 관리할까? 논리 주소, 가상메모리, 페이징

## ✅물리 주소와 논리 주소
- 물리 주소 : 메모리의 HW 상 실제 주소
- 논리 주소 : 프로세스마다 부여되는 0번지부터 시작되는주소 체계

- CPU와 프로세스가 사용하는 주소체계는 논리 주소 
- 중복 되는 물리 주소X, 중복 되는 논리 주소O
- HW상의 메모리와 상호작용하기 위해서는 반드시 논리 주소와 물리 주소간의 변환이 이루어져야 한다.
- 메모리 관리 장치(MMU) : CPU와 메모리 사이에 위치하며, CPU가 이해하는 논리 주소를 메모리가 이해하는 물리 주소로 변환하는 역할 
`CPU` - 논리 주소 -> `MMU` - 물리 주소 -> `메모리`

## ✅스와핑과 연속 메모리 할당
### ▶️스와핑
- 메모리에 적재되어 실행되고 있지 않은 프로세스를 스왑 영역으로 쫒아냄
- 스왑 영역 : 보조기억장치의 일부분 
- 스와핑 : 쫒아낸 자리에 생긴 메모리 상의 빈 공간에 새 프로세스르 적재하여 실행
- 스왑 아웃 : 현재 실행되지 않는 프로세스가 메모리 -> 스왑 영역
- 스왑 인 : 실행할 프로세스가 스왑 영역 -> 메모리 
- 스왑 아웃 후 인될 때는 이전의 물리 주소와는 다른 주소에 적재될 수 있다


- 메모리 내 빈 공간이 여러 개라면 어디에 프로세스를 배치?
### ▶️연속 메모리 할당과 외부 단편화
- 연속 메모리 할당 : 메모리 내에 프로세스들이 연속적으로 배치되는 상황
  - 효율적인 방법X
  - 문제 : 외부 단편화
  - 메모리 사이 사이에 빈 공간이 생겨서 큰 프로세스를 적재하지 못하는 현상 

### ▶️페이징을 통한 가상 메모리 관리 
스와핑과 연속 메모리 할당 문제점 2가지
1. 적재와 삭제를 반복하며 프로세스들 사이에 발생하는 외부 단편화 
2. 물리 메모리보다 큰 프로세스를 실행X

- 해결책 : 가상 메모리 
  - 가상 메모리: 실행하고자 하는 프로그램의 일부분만 메모리에 적재, 실제 메모리보다 더 큰 프로세스를 실행할 수 있도록 만드는 메모리 관리 기법 
  - 보조기억장치의 일부를 메모리처럼 사용하거나 프로세스의 일부만 메모리에 적재함으로써 메모리를 실제 크기보다 더 크게 보이게 하는 기술 
  - 가상 메모리 기법으로 생성된 논리 주소 공간은 가상 주소 공간 
  - 대표 기법 : 페이징, 세크멘테이션 
  
### ▶️페이징
- 가상 메모리 관리 기법 페이징 
  - 프로세스의 논리 주소 공간을 페이지라는 일정한 단위로 나눔
  - 물리 주소 공간을 페이지와 동일한 크기의 프레임이라는 일정한 단위로 나눈 뒤 페이지를 프레임에 할당
  - 프로세스를 구성하는 페이지는 물리 메모리 내에 불연속적으로 배치될 수 있다
  - 외부 단편화X
- 페이지 단위로 스왑 아웃/인 발생 
  - 페이지 아웃 / 페이지 인이라고 함 
  - 같은 프로세스라도 일부는 페이지 인(메모리에), 일부는 페이지 아웃(보조기억장치에) 가능 
  - 프로세스를 실행하기 위해 전체 프로세스가 메모리에 적재될 필요X
- 문제점 
  - 물리 메모리 내에 페이지가 불연속적으로 배치되어 있다면, CPU 입장에서는 다음으로 실행할 페이지의 위치를 찾기 어려움 
  - CPU가 프로세스를 이루는 어떤 페이지가 어떤 프레임에 적재되어 있는지를 모두 알고 있기는 어렵기 때문 

- 세그멘테이션은 페이지 단위가 아닌 가변적인 크기의 세그먼트 단위로 분할하는 방식 
  - 세그먼트는 코드 영역 OR 데이터 영역
  - 외부 단편화O
  
### ▶️페이지 테이블 
- 프로세스의 페이지와 실제로 적재된 프레임을 짝지은 페이지 테이블로 문제 해결 
- 페이지 엔트리 : 페이지 테이블을 구성하고 있는 각각의 행동들 
- 유효 비트 : 해당 페이지 접근 가능 여부 
  - 유효 비트가 0인 페이지에 접근하면 페이지 폴트라는 예외 발생 
  - **페이지 폴트 처리 과정**
    1. CPU가 기존의 작업 내역을 백업
    2. 페이지 폴트 처리 루틴을 실행. 
    페이지 처리 루틴 : 메모리로 원하는 페이지를 가져와 유효 비트를 1로 변경해 주는 작업
    3. 페이지 폴트 처리 루틴 실행 후, 메모리에 적재된 페이지를 실행
    CPU가 해당 페이지에 접근 가능
- 보호 비트 : 페이지 보호 기능
- 참조 비트 : CPU가 해당 페이지에 접근한 적이 있는지 
- 수정 비트(더티 비트) : 해당 페이지에 데이터를 쓴 적이 있는지 
- 외부 단편화는 해결할지라도, 내부 단변화 발생 가능 
- 내부 단편화 : 페이지 하나의 크기보다 작은 크기로 발생하게 되는 메모리 낭비 


- 각 프로세스의 페이지 테이블은 메모리에 적재될 수 있다.
- 페이지 테이블 베이스 레지스터 : 특정 프로세스의 페이지 테이블이 적재된 메모리 상의 위치를 가리키는 특별한 레지스터 
- 프로세스의 페이지 테이블이 모두 메모리에 적재될 경우 
  - 문제: 메모리 접근 횟수가 많아져 성능 저하
페이지 테이블 접근과 실제 데이터 접근으로 인해 메모리 접근이 두 배로 늘어나기 때문
  - 해결: TLB를 사용해 페이 테이블의 일부를 캐싱
  - 문제: 페이지 테이블이 차지하는 메모리 용량이 커져 비효율적
  - 해결: 계층적 페이징 기법을 사용해 페이지 테이블을 나누어 관리
  
### ▶️페이징 주소 체계
- <페이지 번호, 변위>
  - 페이지 번호 : 몇 번째 페이지 번호에 접근할지
  - 변위 : 접근하려는 주소가 페이지 시작 번지로부터 얼만큼 떨어져 있는지 
  
## ✅페이지 교체 알고리즘 
- 요구 페이징 : 메모리에 필요한 페이지만을 적재 
- 순수 요구 페이징 : 아무런 페이지도 적재하지 않은 채 무작정 프로세스를 실행 
- 페이지 교체 알고리즘 : 메모리에 적재된 페이지 중 보조기억장치로 내보낼 페이지를 선택하는 방법 
  1. FIFO 페이지 교체 알고리즘
  2. 최적 페이지 교체 알고리즘
  3. LRU 페이지 교체 알고리즘 
