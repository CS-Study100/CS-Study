# 03-4. CPU 스케줄링
- OS가 프로세스와 스레드에 CPU의 사용을 배분함으로써 CPU 자원을 관리
- CPU scheduling: OS의 CPU 배분 방법
  - CPU 스케줄링 알고리즘 : CPU스케줄링의 절차 
- CPU scheduler : CPU 스케줄링 알고리즘을 결정하고 수행하는 OS의 일부분 

## ✅스케줄링 관련 사전 지식

### ▶️우선순위 
- CPU의 자원을 공정하게 배분하기 위해 
  - 단순히 돌아가면서 CPU를 프로세스에 할당X
  - 프로세스별 우선순위를 판단하여 PCB에 명시, 우선순위에 따라 프로세스에 CPU의 자원을 더 빨리, 더 많이 할당
  - ps 명령어 : 프로세스의 우선순위 확인 가능


- OS는 어떻게 우선순위 할당? CPU 활용률을 기준으로
  - CPU 활용률: 전체 CPU의 가동 시간 중 작업을 처리하는 시간의 비율
  - 기본적으로 입출력이 많은 프로세스의 우선순위를 높게 유지 


- CPU와 입출력장치를 모두 사용해 실행과 대기 상태를 오가며 실행
  - CPU 버스트 : 프로세스가 CPU를 이용하는 작업 
  - 입출력 버스트 : 입출력장치를 기다리는 작업 


- 프로세스마다 입출력장치를 이용하는 시간과 CPU를 이용하는 시간의 양에 차이 존재
  - 입출력 집중 프로세스
    - 입출력을 위한 대기 상태에 더 많이 머무름
  - CPU 집중 프로세스
    - 대기보다 실행 상태에 더 많이 머무름 
- 두 프로세스가 동시에 CPU의 자원을 요구 → 입출력 집중 먼저 작동 후, CPU 집중에 CPU 할당 
  - 입출력 집중이 대기 상태가될거니까, 그 이후에 다른 프로세스를 실행시켜 CPU 활용률을 높일 수 있음 


- 모든 프로세스가 CPU를 차례대로 돌아가며 사용하는 것보다 상황에 맞게 CPU를 배분하는 것이 더 효율적이기 때문에, OS는 프로세스마다 우선순위를 부여해 CPU를 할당 


### ▶️스케줄링 큐 
- 자원을 이용하고 싶다면 줄을 서서 기다릴 것 
  - 이 줄은 스케줄링 큐를 통해 구현
  - 스케줄링에 사용하는 큐가 반드시 선입선출일 필요는 없음 
- OS는 큐에 삽입된 순서대로 실행하되, 우선순위가 높은 프로세스부터 먼저 실행 


- 준비 큐
  - CPU를 이용하고 싶은 프로세스의 PCB가 서는 줄
  - 실행 시간 완료(타이머 인터럽트)인 경우
- 대기 큐
  - 대기 상태에 접어든 프로세스의 PCB가 서는 줄
  - 입출력 작업을 수행하는 경우 
  - 입출력 완료되면 작업이 완료된 PCB를 준비 큐로 이동  
  
### ▶️선점형 스케줄링과 비선점형 스케줄링
- 보통 스케줄링은 프로세스의 실행이 끝나면 이루어짐
- 하지만, 프로세스 실행 도중 스케줄링이 수행되는 시점이 있음 
1. 실행 상태 → 대기 상태(입출력 작업)
2. 실행 상태 → 준비 상태(타이머 인터럽트)

- 선점형 : OS가 프로세스로부터 CPU 자원을 강제로 빼앗아 다른 프로세스에 할당할 수 있는 스케줄링 
  - 1,2 모든 상황에서 수행
  - 장: CPU의 독점을 막고 여러 프로세스에 골고루 CPU 자원을 배분
  - 단: 문맥 교환 과정에서 오버헤드가 발생 
- 비선점형 : 프로세스가 종료되거나 스스로 대기 상태로 접어들때까지 끼어들 수 X
  - 1 상황에서만 수행
  - 장: 상대적으로 적은 오버헤드
  - 단: 당장 CPU를 사용해야하는 프로세스라도 무작정 기다려야함 

<BR>

## ✅CPU 스케줄링 알고리즘
1️⃣**선입 선처리 스케줄링**(FCFS)
- 준비 큐에 삽인된 순서대로 
- 먼저 CPU를 요청한 프로세스부터 CPU를 할당 
- 호위 효과: 먼저 삽입된 프로세스의 오랜 실행 시간으로 나중에 삽입된 프로세스의 실행이 지연 

2️⃣**최단 작업 우선 스케줄링**(SJF)
- CPU를 이용하는 시간의 길이가 가장 짧은 프로세스부터 먼저 실행 
- 기본 비선점형
- 선점형으로도 구현 가능

3️⃣**라운드 로빈 스케줄링**
- 선입 선처리 + 타임 슬라이스
  - 타임 슬라이스: 프로세스가 CPU를 사용하도록 정해진 시간 
- 순서대로 처리하되, 정해진 시간을 모두 사용하면 문맥 교환이 발생해 다시 큐의 맨 뒤에 삽입 

4️⃣**최소 잔여 시간 우선 스케줄링**(SRT)
- 최단 작업 우선 + 라운드 로빈
- 정해진 타임 슬라이스 만큼 사용하되, 남아 있는 작업 시간이 가장 적은 프로세스를 다음으로 선택 

5️⃣**우선순위 스케줄링**
- 가장 높은 우선순위부터 
- 문제: 아사 현상 
  - 우선순위가 낮으면 계속 실행 연기
- 해결: 에이징
  - 오랫동안 대기한 프로세스의 우선순위를 점차 높임
  
6️⃣**다단계 큐 스케줄링**
- 우선순위가 발전된 형태
- 우선순위 별로 여러 개의 준비 큐를 사용 

7️⃣**다단계 피드백 큐 스케줄링**
- 다단계 큐의 아사 현상 해결
- 프로세스들이 큐 사이를 이동할 수 있다 
- 오래 CPU를 사용해야하는 프로세스의 우선순위가 점차 낮아짐 
- 에이징 기법도 적용 가능

<BR>

## ✅리눅스 CPU 스케줄링
- 리눅스는 상황에 따라 다양한 스케줄링 알고리즘 사용 가능 
- 스케줄링 정책 : 새로운 프로세스를 언제 어떻게 선택하여 실행할지를 결정하기 위한 규칙의 집합 
  - FIFO, RoundRobin : RealTime 스케줄러에 의해 이뤄지는 스케줄링 
  - NORMAL : 일반적인 프로세스에 적용되는 스케줄링 
    - **CFS**: 완전히 공평한 CPU 시간 배분(Completely Fair Scheduler)
    - 가상 실행 시간이 가장 작은 프로세스부터 스케줄링 
    - vruntime은 프로세스가 실제로 실행된 시간x, 가중치를 고려한 가상의 실행 시간 
    - 프로세스의 가중치가 높을수록 먼저 스케줄링될 확률이 높다
    - 프로세스의 우선순위가 높아질수록 가중치도 높아진다
    
