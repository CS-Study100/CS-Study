# 3-4 CPU 스케줄링(CPU scheduling) 
운영체제는 다양한 프로세스와 스레드에 **CPU의 사용을 배분** 함으로써 CPU 자원을 관리한다.
`CPU 스케줄링` : 운영체제의 CPU 배분 방법이다.
`CPU 스케줄링 알고리즘` : CPU 스케줄링의 절차
`CPU 스케줄러` : CPU 스케줄링 알고리즘을 결정하고 수행하는 운영체제의 일부분

> 실행의 문맥이 있다면 모두 스케줄링의 대상

## ✅ 우선순위(Priority)	
CPU의 자원을 공정하게 배분하는 방법
- 운영체제는 프로세스별 **우선순위**를 판단하여 PCB에 명시하고, 우선순위가 높은 프로세스에는 CPU의 자원을 더 빨리, 더 많이 할당한다.
- 사용자가 일부 프로세스의 우선순위를 직접 높일 수도 있다.
- `ps` 명령어를 통해 프로세스 우선순위 확인 가능
### ☑️ 우선순위 할당 기준
CPU 활용률(CPU utilization) : 전체 CPU의 가동 시간 중 작업을 처리하는 시간의 비율을 의미
- 운영체제는 높은 CPU 활용률을 유지하기 위해 기본적으로 입출력 작업이 많은 프로세스의 우선순위를 높게 유지함

### ☑️ CPU 활용률을 통한 우선순위 배분
입출력 집중 프로세스와 CPU 집중 프로세스를 구분하고, 각 프로세스의 특성에 맞춰 자원을 배분하는 방식은 CPU 활용률을 최적화하는 우선순위이다.

#### 입출력 집중 프로세스와 CPU 집중 프로세스
입출력 집중 프로세스를 먼저 처리하여 입출력 장치를 효율적으로 활용하고, 이후 CPU 집중 프로세스를 실행하여 CPU 자원을 최적화하는 방식이 가장 효율적
**➡️ 시스템 전체의 자원 활용도를 높이고, CPU 활용률을 극대화 가능**

- 입출력 집중 프로세스 (I/O Bound Process)
	- CPU 자원을 적게 사용하고, 대부분 대기 상태에 있다.
    - 입출력 장치가 작업을 완료할 때까지 대기 상태가 길어지므로, 이 프로세스를 우선 처리하면 시스템 자원의 낭비를 줄일 수 있다.

- CPU 집중 프로세스 (CPU Bound Process)
	- CPU를 많이 사용하며 대기 시간이 적다. 
    - 이 프로세스는 CPU 자원을 효율적으로 사용하는 반면, 입출력 장치 자원은 상대적으로 적게 활용한다.
    
## ✅ 스케줄링 큐 (scheduling queue)
운영체제는 프로세스들에게 `자원을 이용하고 싶다면 줄을 서서 기다릴 것` 을 요구한다.
**스케줄링 큐**가 줄에 해당한다.
### 준비 큐(ready queue)
- CPU를 이용하고 싶은 프로세스의 PCB가 서는 줄을 의미
### 대기 큐(waiting queue)
- 대기 상태에 접어든 프로세스의 PCB가 서는 줄을 의미
 
 
## ✅ 선점형 스케줄링과 비선점형 스케줄링
스케줄링은 기본적으로 프로세스의 실행이 끝나면 이루어진다.
하지만 !! 프로세스가 종료되지 않았음에도 실행 도중 스케줄링이 수행되는 대표적인 두 시점이 있다.
 
1️⃣ 실행 상태에서 입출력 작업을 위해 대기 상태로 전환될 때 2️⃣ 실행 상태에서 타이머 인터럽트가 발생해 준비 상태로 변경될 때
 
```
실행 도중 스케줄링이 이루어지는 경우 ──> 1️⃣실행 상태 ──> 대기 상태(입출력 작업)
                        	│
                     		└──> 2️⃣실행 상태 ──> 준비 상태(타이머 인터럽트)
```

### ☑️ 선점형 스케줄링 
**더 높은 우선순위를 가진 프로세스가 언제든 CPU를 차지할 수 있는 방식**
- 1️⃣, 2️⃣ 모든 상황에서 수행되는 스케줄링 유형
- 타이머 인터럽트 기반 스케줄링은 모두 선점형 스케줄링의 일종이다.
 -	프로세스마다 정해진 시간만큼만 CPU를 이용하고, 정해진 시간을 모두 소비하면 운영체제가 해당 프로세스로부터 CPU 자원을 빼앗아 다음 프로세스에게 할당하는 방식
- 장점
 	- CPU 독점 방지: 한 프로세스가 CPU를 독점하지 않도록 막아줌
	- 자원 배분의 공정성: 여러 프로세스가 CPU 자원을 고르게 배분 가능
- 단점
	- 문맥 교환 오버헤드: 더 높은 우선순위의 프로세스가 끼어들 때마다 문맥 교환이 발생하여 CPU 오버헤드가 증가할 수 있음
 
### ☑️ 비선점형 스케줄링
**현재 실행 중인 프로세스가 작업을 끝낼 때까지 CPU를 계속 점유하는 방식**
- 1️⃣ 상황에서만 수행되는 스케줄링 유형
-장점
	- 오버헤드 감소: 문맥 교환 횟수가 적어 선점형 스케줄링보다 상대적으로 오버헤드가 적음
- 단점
	- 긴 대기 시간 발생 가능: 현재 프로세스가 CPU를 점유하고 있는 동안 더 높은 우선순위를 가진 프로세스도 대기해야 하므로 긴 대기 시간이 발생할 수 있음

 
## ✅ CPU 스케줄링 알고리즘
운영체제가 프로세스에 CPU를 배분하는 방법
### ☑️ 종류
#### 선입 선처리 스케줄링 (FCFS)
- 단순히 준비 큐에 삽입된 순서대로 먼저 CPU를 요청한 프로세스부터 CPU를 할당하는 스케줄링 방식
- 때때로 프로세스들이 기다리는 시간이 매우 길어질 수 있다는 부작용 존재
- **호위 효과(convoy effect)** : 먼저 삽입된 프로세스의 오랜 실행 시간으로 인해 나중에 삽입된 프로세스의 실행이 지연되는 문제

#### 최단 작업 우선 스케줄링(SJF)
- 준비 큐에 삽입된 프로세스 중 CPU를 이용하는 시가느이 길이가 가장 짧은 프로세스부터 먼저 실행하는 스케줄링 방식

#### 라운드 로빈 스케줄링(round robin)
- 큐에삽입된프로세스들이 삼입된순서대로CPU를이용하되,정해진타임 슬라이스만큼만 CPU를 이용
	- 타임 슬라이스 : 프로세스가 CPU를 사용하도록 정해진 시간 의미

#### 최조 잔여 시간 우선 스케줄링(SRT)
- 최단 작업 우선 스케줄링 + 로빈 스케줄링
	- 프로세스로 하여금 정해진 타입 슬라이스만큼 CPU를 이용하되, 남아있는 작업시간이 가장 적은 프로세스를 다음으로 CPU를 이용할 프로세스로 선택
    
#### 우선순위 스케줄링
- 프로세스에 우선순위를 부여하고, 가장 높은 우선순위를 가진 프로세스부터 실행하는 스케줄링 방식

#### 다단계 큐 스케줄링
- 우선순위 스케줄링의 발전된 형태
- 우선순위별로 여러 개의 준비 큐를 사용하는 스케줄링 방식

#### 다단계 피드백 큐 스케줄링
- 다단계 큐 스케줄링에 피드백(Feedback) 개념을 추가한 방식

---
