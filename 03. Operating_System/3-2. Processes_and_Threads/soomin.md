## ✅프로세스

- 프로세스 유형
  - 포그라운드 프로세스 : 사용자가 보는 곳
  - 백그라운드 프로세스 : 사용자 보지 못하는 곳
    - ⊃ 데몬(=서비스) : 주어진 작업만 수행 

 - 유형을 막론하고, 
 하나의 프로세스를 구성하는 메모리 내의 정보는 공통
   - 커널 영역 - PCB
   - 사용자 영역 - 스택 | 힙 | 데이터 | 코드
     - 정적 할당 영역
       - **코드** - 실행 가능한 명령어가 저장
       - **데이터** - 정적 변수, 전역 변수
    
     - 동적 할당 영역
       - **힙** - 사용자가 직접 할당 가능 (메모리 누수, 가비지 컬렉션)
       - **스택** - 매개 변수, 지역 변수, 함수 복귀 주소
         - <SMALL>스택 트레이스 - 특정 시점에 스택 영역에 저장된 함수 호출 정보, 디버깅에 유용</SMALL>
       
### ▶️PCB와 문맥 교환
- Process Control Block : 프로세스를 식별할 수 있는 커널 영역 내의 정보
  - 프로세스ID
  - 실행 과정에서 사용되는 레지스터 값
  - 프로세스 상태
  - CPU 스케줄링(우선순위) 정보
  - 메모리 관련 정보
  - 파일 및 입출력장치 관련 정보 

- 프로세스 생성 됐을 때 PCB가 커널 영역에 만들어지고, 실행 끝나면 폐기 됨 

- PCB들은 커널 내에 프로세스 테이블의 형태로 관리
  - 실행되는 프로세스 - 테이블에 PCB 추가
  - 종료되는 프로세스 - 테이블에서 PCB 제거
    - <SMALL>비정상 종료 상태 = 좀비 프로세스</SMALL>

- 프로세스가 실행된다 = OS에 의해 CPU의 자원을 할당 받았다
- 프로세스의 CPU 사용 시간 - 타이머 인터럽트에 의해 제한됨 

- 문맥 교환
  - OS는 프로세스A의 문맥 PCB에 저장(백업) → 프로세스B의 문맥 복구
    - 자주 발생하면 좋을까? X
      - 캐시 미스가 발생할 가능성 높아져 메모리로부터 실행할 프로세스의 내용을 가져오는 작업이 빈번해지고, 이는 큰 오버헤드로 이어질 수 있다. 
   
### ▶️프로세스의 상태
- 생성 → 준비
- 준비 → 실행 : 디스패치
- 실행 → 준비 : 타이머 인터럽트
- 실행 → 대기 : 곧장 실행이 불가
- 실행 → 종료 
- 대기 → 준비 : 실행 재개가 가능 

🔷블로킹 VS. 논블로킹
- 프로세스가 시스템 콜이 발생했을 때
  - 블로킹 입출력 : 대기
  - 논 블로킹 입출력 : 실행 

## ✅멀티프로세스와 멀티스레드
- 멀티프로세스 VS. 멀티스레드 : **자원의 공유 여부**
   - 멀티프로세스 - 자원 공유 X, 독립적 실행
   - 멀티스레드 - 자원 공유 O
     - 단점 : 한 스레드에서 생긴 문제가 프로세스의 전체 문제가 될 수 있음 

## ✅프로세스 간 통신
- Inter-Process Communication
  - 프로세스 간에도 자원을 공유하고 데이터를 주고 받을 수 있는 방법 
- IPC방식 2가지
  1. 공유 메모리
  2. 메시지 전달 
  
### ▶️공유 메모리
- 프로세스 간에 공유하는 메모리 영역을 토대로 데이터를 주고받는 통신 방식 
- 각 프로세스가 마치 자신의 메모리 영역을 읽고 쓰는 것처럼 통신 
- 문제 : 레이스 컨디션

### ▶️메시지 전달
- 보내는 수단과, 받는 수단이 명확히 구분 
- 단점 : 속도 느림 
- 대표적인 수단
  - 파이프 - 단방향, 양방향
  - 시그널 - 특정 이벤트가 발생했음을 알리는 비동기적인 신호, 시그널 핸들러 사용 
  - 네트워크 소켓
  - 원격 프로시저 호출 - 대규모 트래픽 처리 환경에서 사용 
