# 3. 운영체제

## 3-2. 프로세스와 스레드

운영체제의 핵심기능:  

1.자원 할당 및 관리   
**<ins> 2. 프로세스 및 스레드 관리 </ins>** 
   
---
### 💻 프로세스 및 스레드 관리
#### 프로세스 종류
- 포그라운드 프로세스: 사용자가 보는 공간에서 사용자와 상호작용하며 실행되는 프로세스
- 백그라운드 프로세스: 사용자가 보지 못하는 곳에서 실행되는 프로세스
	
    - 데몬: 사용자와 별다른 상호작용 없이 주어진 작업만 수행하는 특별한 백그라운드 프로세스(윈도우의 경우 `서비스`라고 부름)
    
#### 프로세스가 저장되는 메모리 영역
- 커널 영역: 프로세스 제어 블록(PCB)가 저장
- 사용자 영역: 실행중인 프로세스가 `코드`, `데이터`, `힙`, `스택` 영역으로 나뉘어 저장
	
  - 정적 할당 영역 (프로그램 실행 도중 크기 불변)
   
    + `코드` 영역(텍스트 영역): 실행 가능한 명령어가 저장되는 공간 (읽기 전용)	
   
    + `데이터` 영역: 프로그램이 실행되는 동안 유지할 데이터가 저장되는 공간
    저장되는 데이터 ex) 정적 변수, 전역 변수
    
  - 동적 할당 영역(프로그램 실행 도중 크기 가변)
  
    + `힙` 영역: 사용자(개발자)가 직접 할당 가능한 저장 공간
    but, 힙 영역에 메모리 공간 할당 → 언젠가는 해당 공간 반환해야
    메모리 누수의 문제 초래하지 않을 수 있음
   
    + `스택` 영역: 데이터 영역과는 달리, 일시적으로 사용할 값들이 저장되는 공간
    저장되는 데이터 ex) 매개변수, 지역 변수, 함수 복귀 주소, 스택 트레이스
    cf.) 스택 트레이스: 특정 시점에 스택 영역에 저장된 함수 호출 정보
    
---   
### 💻 PCB와 문맥 교환
 운영체제가 적재된 다수의 프로세스를 관리하기 위해선 프로세스 식별을 위한 커널 영역 내의 정보인 `PCB`가 필요

#### PCB란
`프로세스 제어 블록(Process Control Block)`
: 프로세스와 관련된 다양한 정보를 내포하는 구조체의 일종으로,
새로운 프로세스 생성(프로세스가 메모리에 적재)됐을 때 커널 영역에 만들어지고, 프로세스가 종료(프로세스가 메모리에서 해제)되면 폐기된다.

#### PCB에 저장되는 정보
- 프로세스 ID (PID)
- 프로세스가 실행 과정에서 사용한 레지스터 값
- 프로세스 상태
- CPU 스케줄링(우선순위) 정보
- 메모리 관련 정보
- 파일 및 입출력장치 관련 정보

``` cpp

// Linux 운영체제의 PCB
struct task_struct{
  pid_t pid;      // PID
  Int prio;     // 스케줄링(우선 순위) 관련 정보
  unsigned int_state;     // 프로세스 상태 관련 정보
  struct mm_struct * mm;    // 메모리 관련 정보
  void * stack;     // 스택 관련 정보
  struct files struct * files;    // 파일 관련 정보
  ...
}

```

여러 PCB들은 커널 내의 `프로세스 테이블`의 형태로 관리되는 경우가 많음
즉, `프로세스 테이블` = `실행 중인 PCB의 모음`

새롭게 실행되는 프로세스 → 해당 프로세스의 PCB를 프로세스 테이블에 추가, 필요한 자원 할당

종료되는 프로세스 → 사용 중이던 자원 해제, 해당 프로세스의 PCB를 프로세스 테이블에서 삭제

#### 문맥 교환
일반적으로 메모리에 적재된 프로세스들은 한정된 시간 동안 번갈아 가며 실행
(프로세스가 실행된다 = 운영체제의 의해 CPU의 자원을 할당받았다)
즉, CPU 사용시간이 제한된다는 것

이때, CPU 사용 시간은 `타이머 인터럽트`에 의해 제한됨
>**타이머 인터럽트(타임아웃 인터럽트)**
: CPU 사용 시간이 끝났음을 알리는 인터럽트
>
> 타이머 인터럽트가 발생하면, 실행중이었던 프로세스는 지금까지의 중간 정보를 백업해야 한다. 해당 정보를 `문맥`이라 한다.
>
>`문맥`: 프로세스의 수행을 재개하기 위해 기억해야할 정보

프로세스의 문맥은 해당 프로세스의 PCB에 명시됨

>  #### 📌 정리
>  타이머 인터럽트 발생 → 운영체제는 실행중이던 프로세스의 PCB에 문맥을 백업
>  → 뒤이어 실행할 프로세스의 문맥을 복구
>
>  해당 과정에서 실행중이던 프로세스의 문맥과 실행할 프로세스의 문맥이 교환되는 것을 `문맥 교환(context switching)`이라고 한다.


🧐 **문맥 교환이 자주 발생하는 것이 좋을까?**
→ NO!   
잦은 문맥 교환은 캐시 미스 가능성을 높이고 이는 큰 오버헤드로 이어질 수 있다.

---
### 💻 프로세스의 상태
![](https://velog.velcdn.com/images/clevelog/post/5a6a8799-6493-4c42-b07c-fce83a8e36d9/image.jpeg)

---
### 💻 멀티프로세스와 멀티스레드
`멀티프로세스`: 동시에 여러 프로세스가 실행되는 것
`멀티스레드`: 동시에 여러 스레드가 실행되는 것  
(즉, 프로세스를 동시에 실행하는 여러 스레드가 존재하는 것)

#### 둘의 차이점
: 자원의 공유 여부

멀티프로세스: 서로 자원을 공유하지 X, 독립적
	
    장점: 서로 영향을 거의 끼치지 X 
    단점: 서로 쉽게 협력하고 통신할 수 없다

멀티스레드: 서로 자원을 공유 O, 종속적
	
    장점: 서로 쉽게 협력하고 통신할 수 있다
	단점: 한 스레드에 생긴 문제가 프로세스 전체의 문제가 될 수 있다
    
cf.) 멀티스레드는 같은 프로세스를 공유하기 때문에, PID값은 같고 스레드 ID값은 다르다

### 💻 프로세스 간 통신
앞서 말했듯, 프로세스는 기본적으로 자원을 공유하지 않는다.
하지만, 프로세스 간에도 자원을 공유하고 데이터를 주고 받을 수 있는 방법이 존재

→ `프로세스 간 통신(IPC, Inter-Process Communication)`

#### 통신 유형
1. 공유 메모리
: 프로세스가 공통적으로 사용할 메모리 영역을 두는 방식
   ```
   장점: 
    1. 데이터를 주고받는 과정에 커널의 개입이 거의 없다
    2. 메시지 전달 방식보다 통신 속다 빠르다
    
   단점: 레이스 컨디션 발생 가능
   ```    
    
2. 메시지 전달
: 프로세스 간에 주고받을 데이터를 커널을 거쳐 메시지의 형태로 주고받는 방식
   ```
   장점: 커널의 도움을 받아 레이스 컨디션, 동기화 등의 문제를 고려하는 일이 상대적으로 적다 
   단점: 공유 메모리 방식보다 통신 속도가 느리다
   ```

3. 원격 프로시저 호출(RPC)
4. 네트워크 소켓

